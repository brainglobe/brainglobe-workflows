{"project": "brainglobe_workflows", "project_url": "https://github.com/brainglobe/brainglobe-workflows", "show_commit_url": "https://github.com/brainglobe/brainglobe-workflows/commit/", "hash_length": 8, "revision_to_hash": {"440": "00970cc1c83097abfcd4bba41e4d8e1d34914e20"}, "revision_to_date": {"440": 1697110088000}, "params": {"arch": ["arm64"], "cpu": ["Apple M1 Pro"], "machine": ["eduroam-int-dhcp-97-153-159.ucl.ac.uk"], "num_cpu": ["10"], "os": ["Darwin 23.0.0"], "ram": ["34359738368"], "python": ["3.10"], "branch": ["smg/cellfinder-cli-benchmark"]}, "graph_param_list": [{"arch": "arm64", "cpu": "Apple M1 Pro", "machine": "eduroam-int-dhcp-97-153-159.ucl.ac.uk", "num_cpu": "10", "os": "Darwin 23.0.0", "ram": "34359738368", "python": "3.10", "branch": "smg/cellfinder-cli-benchmark"}], "benchmarks": {"cellfinder.TimeDetectCells.time_cellfinder_run": {"code": "class TimeDetectCells:\n    def time_cellfinder_run(self):\n        cellfinder_run(\n            self.signal_array, self.background_array, self.cfg.voxel_sizes\n        )\n\n    def setup(self):\n        # basic setup\n        TimeBenchmarkPrepGIN.setup(self)\n    \n        # add input data as arrays to config\n        self.signal_array = read_with_dask(self.cfg.signal_dir_path)\n        self.background_array = read_with_dask(self.cfg.background_dir_path)\n\nclass TimeBenchmarkPrepGIN:\n    def setup_cache(\n        self,\n    ):\n        \"\"\"\n        Download the input data from the GIN repository to the local\n        directory specified in the default_config.json\n    \n        Notes\n        -----\n        The `setup_cache` method only performs the computations once\n        per benchmark round and then caches the result to disk [1]_. It cannot\n        be parametrised [2]_.\n    \n    \n        [1] https://asv.readthedocs.io/en/latest/writing_benchmarks.html#setup-and-teardown-functions\n        [2] https://asv.readthedocs.io/en/latest/writing_benchmarks.html#parameterized-benchmarks\n        \"\"\"\n    \n        # Check config file exists\n        assert Path(self.input_config_path).exists()\n    \n        # Instantiate a CellfinderConfig from the input json file\n        # (assumes config is json serializable)\n        with open(self.input_config_path) as cfg:\n            config_dict = json.load(cfg)\n        config = CellfinderConfig(**config_dict)\n    \n        # Download data with pooch\n        _ = pooch.retrieve(\n            url=config.data_url,\n            known_hash=config.data_hash,\n            path=config.install_path,\n            progressbar=True,\n            processor=pooch.Unzip(extract_dir=config.extract_dir_relative),\n        )\n    \n        # Check paths to input data should now exist in config\n        assert Path(config.signal_dir_path).exists()\n        assert Path(config.background_dir_path).exists()", "min_run_count": 2, "name": "cellfinder.TimeDetectCells.time_cellfinder_run", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "setup_cache_key": "cellfinder:84", "timeout": 600, "type": "time", "unit": "seconds", "version": "a37269e5549803517d14817f7e9aede2930f6ba97c3faeba7235de092a74f6c8", "warmup_time": 0.1}, "cellfinder.TimeFullWorkflow.time_workflow_from_cellfinder_run": {"code": "class TimeFullWorkflow:\n    def time_workflow_from_cellfinder_run(self):\n        run_workflow_from_cellfinder_run(self.cfg)\n\nclass TimeBenchmarkPrepGIN:\n    def setup(self):\n        \"\"\"\n        Run the cellfinder workflow setup steps.\n    \n        The command line input arguments are injected as dependencies.\n        \"\"\"\n    \n        # Run setup\n        cfg = setup_cellfinder_workflow(\n            [\n                \"--config\",\n                self.input_config_path,\n            ]\n        )\n    \n        # Save configuration as attribute\n        self.cfg = cfg\n\n    def setup_cache(\n        self,\n    ):\n        \"\"\"\n        Download the input data from the GIN repository to the local\n        directory specified in the default_config.json\n    \n        Notes\n        -----\n        The `setup_cache` method only performs the computations once\n        per benchmark round and then caches the result to disk [1]_. It cannot\n        be parametrised [2]_.\n    \n    \n        [1] https://asv.readthedocs.io/en/latest/writing_benchmarks.html#setup-and-teardown-functions\n        [2] https://asv.readthedocs.io/en/latest/writing_benchmarks.html#parameterized-benchmarks\n        \"\"\"\n    \n        # Check config file exists\n        assert Path(self.input_config_path).exists()\n    \n        # Instantiate a CellfinderConfig from the input json file\n        # (assumes config is json serializable)\n        with open(self.input_config_path) as cfg:\n            config_dict = json.load(cfg)\n        config = CellfinderConfig(**config_dict)\n    \n        # Download data with pooch\n        _ = pooch.retrieve(\n            url=config.data_url,\n            known_hash=config.data_hash,\n            path=config.install_path,\n            progressbar=True,\n            processor=pooch.Unzip(extract_dir=config.extract_dir_relative),\n        )\n    \n        # Check paths to input data should now exist in config\n        assert Path(config.signal_dir_path).exists()\n        assert Path(config.background_dir_path).exists()", "min_run_count": 2, "name": "cellfinder.TimeFullWorkflow.time_workflow_from_cellfinder_run", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "setup_cache_key": "cellfinder:84", "timeout": 600, "type": "time", "unit": "seconds", "version": "972079517fbc189a9acc0af554fc3c8382e2add170992dfde452a1b5180a7910", "warmup_time": 0.1}, "cellfinder.TimeReadInputDask.time_read_background_with_dask": {"code": "class TimeReadInputDask:\n    def time_read_background_with_dask(self):\n        read_with_dask(self.cfg.background_dir_path)\n\nclass TimeBenchmarkPrepGIN:\n    def setup(self):\n        \"\"\"\n        Run the cellfinder workflow setup steps.\n    \n        The command line input arguments are injected as dependencies.\n        \"\"\"\n    \n        # Run setup\n        cfg = setup_cellfinder_workflow(\n            [\n                \"--config\",\n                self.input_config_path,\n            ]\n        )\n    \n        # Save configuration as attribute\n        self.cfg = cfg\n\n    def setup_cache(\n        self,\n    ):\n        \"\"\"\n        Download the input data from the GIN repository to the local\n        directory specified in the default_config.json\n    \n        Notes\n        -----\n        The `setup_cache` method only performs the computations once\n        per benchmark round and then caches the result to disk [1]_. It cannot\n        be parametrised [2]_.\n    \n    \n        [1] https://asv.readthedocs.io/en/latest/writing_benchmarks.html#setup-and-teardown-functions\n        [2] https://asv.readthedocs.io/en/latest/writing_benchmarks.html#parameterized-benchmarks\n        \"\"\"\n    \n        # Check config file exists\n        assert Path(self.input_config_path).exists()\n    \n        # Instantiate a CellfinderConfig from the input json file\n        # (assumes config is json serializable)\n        with open(self.input_config_path) as cfg:\n            config_dict = json.load(cfg)\n        config = CellfinderConfig(**config_dict)\n    \n        # Download data with pooch\n        _ = pooch.retrieve(\n            url=config.data_url,\n            known_hash=config.data_hash,\n            path=config.install_path,\n            progressbar=True,\n            processor=pooch.Unzip(extract_dir=config.extract_dir_relative),\n        )\n    \n        # Check paths to input data should now exist in config\n        assert Path(config.signal_dir_path).exists()\n        assert Path(config.background_dir_path).exists()", "min_run_count": 2, "name": "cellfinder.TimeReadInputDask.time_read_background_with_dask", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "setup_cache_key": "cellfinder:84", "timeout": 600, "type": "time", "unit": "seconds", "version": "bf1a26a9a90c3686fe63ef495a40bda58641061ee504e8aa682554ff5f25506b", "warmup_time": 0.1}, "cellfinder.TimeReadInputDask.time_read_signal_with_dask": {"code": "class TimeReadInputDask:\n    def time_read_signal_with_dask(self):\n        read_with_dask(self.cfg.signal_dir_path)\n\nclass TimeBenchmarkPrepGIN:\n    def setup(self):\n        \"\"\"\n        Run the cellfinder workflow setup steps.\n    \n        The command line input arguments are injected as dependencies.\n        \"\"\"\n    \n        # Run setup\n        cfg = setup_cellfinder_workflow(\n            [\n                \"--config\",\n                self.input_config_path,\n            ]\n        )\n    \n        # Save configuration as attribute\n        self.cfg = cfg\n\n    def setup_cache(\n        self,\n    ):\n        \"\"\"\n        Download the input data from the GIN repository to the local\n        directory specified in the default_config.json\n    \n        Notes\n        -----\n        The `setup_cache` method only performs the computations once\n        per benchmark round and then caches the result to disk [1]_. It cannot\n        be parametrised [2]_.\n    \n    \n        [1] https://asv.readthedocs.io/en/latest/writing_benchmarks.html#setup-and-teardown-functions\n        [2] https://asv.readthedocs.io/en/latest/writing_benchmarks.html#parameterized-benchmarks\n        \"\"\"\n    \n        # Check config file exists\n        assert Path(self.input_config_path).exists()\n    \n        # Instantiate a CellfinderConfig from the input json file\n        # (assumes config is json serializable)\n        with open(self.input_config_path) as cfg:\n            config_dict = json.load(cfg)\n        config = CellfinderConfig(**config_dict)\n    \n        # Download data with pooch\n        _ = pooch.retrieve(\n            url=config.data_url,\n            known_hash=config.data_hash,\n            path=config.install_path,\n            progressbar=True,\n            processor=pooch.Unzip(extract_dir=config.extract_dir_relative),\n        )\n    \n        # Check paths to input data should now exist in config\n        assert Path(config.signal_dir_path).exists()\n        assert Path(config.background_dir_path).exists()", "min_run_count": 2, "name": "cellfinder.TimeReadInputDask.time_read_signal_with_dask", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "setup_cache_key": "cellfinder:84", "timeout": 600, "type": "time", "unit": "seconds", "version": "d01c253717edd52a017c710e569a36349c463b190e1ac4f0ab786c16cde75bd5", "warmup_time": 0.1}, "cellfinder.TimeSaveCells.time_save_cells": {"code": "class TimeSaveCells:\n    def time_save_cells(self):\n        save_cells(self.detected_cells, self.cfg.detected_cells_path)\n\n    def setup(self):\n        # basic setup\n        TimeBenchmarkPrepGIN.setup(self)\n    \n        # add input data as arrays to config\n        self.signal_array = read_with_dask(self.cfg.signal_dir_path)\n        self.background_array = read_with_dask(self.cfg.background_dir_path)\n    \n        # detect cells\n        self.detected_cells = cellfinder_run(\n            self.signal_array, self.background_array, self.cfg.voxel_sizes\n        )\n\nclass TimeBenchmarkPrepGIN:\n    def setup_cache(\n        self,\n    ):\n        \"\"\"\n        Download the input data from the GIN repository to the local\n        directory specified in the default_config.json\n    \n        Notes\n        -----\n        The `setup_cache` method only performs the computations once\n        per benchmark round and then caches the result to disk [1]_. It cannot\n        be parametrised [2]_.\n    \n    \n        [1] https://asv.readthedocs.io/en/latest/writing_benchmarks.html#setup-and-teardown-functions\n        [2] https://asv.readthedocs.io/en/latest/writing_benchmarks.html#parameterized-benchmarks\n        \"\"\"\n    \n        # Check config file exists\n        assert Path(self.input_config_path).exists()\n    \n        # Instantiate a CellfinderConfig from the input json file\n        # (assumes config is json serializable)\n        with open(self.input_config_path) as cfg:\n            config_dict = json.load(cfg)\n        config = CellfinderConfig(**config_dict)\n    \n        # Download data with pooch\n        _ = pooch.retrieve(\n            url=config.data_url,\n            known_hash=config.data_hash,\n            path=config.install_path,\n            progressbar=True,\n            processor=pooch.Unzip(extract_dir=config.extract_dir_relative),\n        )\n    \n        # Check paths to input data should now exist in config\n        assert Path(config.signal_dir_path).exists()\n        assert Path(config.background_dir_path).exists()", "min_run_count": 2, "name": "cellfinder.TimeSaveCells.time_save_cells", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "setup_cache_key": "cellfinder:84", "timeout": 600, "type": "time", "unit": "seconds", "version": "7c1d5133e9b37b475e715b17d7d1ffaf8094679919a0ff1b8ac5625936d8af91", "warmup_time": 0.1}}, "machines": {"eduroam-int-dhcp-97-153-159.ucl.ac.uk": {"arch": "arm64", "cpu": "Apple M1 Pro", "machine": "eduroam-int-dhcp-97-153-159.ucl.ac.uk", "num_cpu": "10", "os": "Darwin 23.0.0", "ram": "34359738368", "version": 1}}, "tags": {}, "pages": [["", "Grid view", "Display as a agrid"], ["summarylist", "List view", "Display as a list"], ["regressions", "Show regressions", "Display information about recent regressions"]]}